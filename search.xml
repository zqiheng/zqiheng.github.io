<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Servlet（二）之HttpServlet开发]]></title>
    <url>%2F2018%2F09%2F27%2FServlet%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8BHttpServlet%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[前面简单的介绍了Servlet相关的技术特点以及生命周期，下面介绍Servlet常用的开发方法及步骤。 说明：在实际的开发的Web项目中，大多数我们采用Servlet技术开发时，是通过继承的HttpServlet类，而不是实现Servlet接口。HttpServlet类存放在javax.servlet.http包内，是针对使用HTTP协议的Web服务器的Servlet类。HttpServlet类通过执行Servlet接口，能够提供HTTP协议的功能。 1.Servlet创建创建一个Servlet，通常涉及下列4个步骤。 1）继承HttpServlet抽象类。 2）重载适当的方法，如覆盖（重写）doGet()方法或doPost()方法。 3）如果有HTTP请求信息的话，获取该信息。可通过调用HttpServletRequest类对象的以下3个方法获取。 123getParameterNames() //获取请求中所有参数的名字getParameter() //获取请求中指定参数的值getParameterValues() //获取请求中所有参数的值 4）生成HTTP响应。HttpServletResponse类对象生成响应，并将它返回到发出请求的客户机上。它的方法允许设置“请求”标题和“响应”主体。“响应”对象还包含有getWriter()方法以返回一个PringWriter类对象。 以下为按照上述步骤创建的Servlet类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.heng.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * 第一步：继承HttpServlet类 */@WebServlet(&quot;/helloHttpServlet&quot;)public class MyHttpServelt extends HttpServlet &#123; /** * 第二步：重写doGet()或doPost()方法 * @param request * @param response * @throws ServletException * @throws IOException */ @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; /** * 第三步：获取HTTP请求信息 */ String myName = request.getParameter(&quot;myName&quot;); /** * 第四步：生成HTTP响应 */ response.setContentType(&quot;text/html;charset=gb2312&quot;); response.setHeader(&quot;Pragma&quot;,&quot;No-cache&quot;); response.setDateHeader(&quot;Expires&quot;,0); response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&lt;title&gt;一个简单的Servlet程序&lt;/title&gt;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;Servlet程序&lt;/h1&gt;&quot;); out.println(&quot;&lt;p style=&apos;color:red&apos;&gt;&quot;+myName+&quot;您好，欢迎使用本程序！！！&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req, resp); &#125;&#125; 运行结果： 2.Servlet的配置创建了Servlet类后，还需要对Servlet进行配置。配置的目的是为了将创建的Servlet注册到Servlet容器之中，以方便Servlet容器对Servlet的调用。 2.1 在web.xml文件中配置Servlet1）Servlet的名称、类和其他选项的配置 12345678910&lt;servlet&gt; &lt;!--Servlet名称--&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;!--Servlet类的全路径--&gt; &lt;servlet-class&gt;com.heng.servlet.MyServelt&lt;/servlet-class&gt; &lt;!--Servlet描述信息--&gt; &lt;description&gt;Simple Servlet&lt;/description&gt; &lt;!--指定发布时Servlet的名称--&gt; &lt;display-name&gt;Servlet&lt;/display-name&gt;&lt;/servlet&gt; 2）Servlet的映射在web.xml配置文件中可以给一个Servlet做多个映射，因此，可以通过不同的方法访问这个Servlet。 123456&lt;servlet-mapping&gt; &lt;!--与上面的Servlet名称一定要保持一致--&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;!--请求路径，格式较多。例如/*、/helloServlet、/one/*、*.do、*.action等等--&gt; &lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3）初始化参数Servlet可以配置一些初始化参数。 123456&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;number&lt;/param-name&gt; &lt;param-value&gt;10000&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 在上述代码中，指定number的参数值为10000.在Servlet中可以在init()方法体中通过getInitParameter()方法访问这些初始化参数。 4）启动装入优先权启动装入优先权通过元素指定。 重点 2.2 采用注解配置Servlet采用注解配置Servlet的基本语法如下。 1234567import javax.servlet.annotation.WebServlet;@WebServlet(urlPatterns = &#123;&quot;/映射地址&quot;&#125;,asyncSupported=true|false,loadOnStartup = -1,name = &quot;Servlet名称&quot;,displayName = &quot;显示名称&quot;,initParams = &#123;@WebInitParam(name = &quot;username&quot;,value = &quot;值&quot;)&#125;) 在上面的语法中，urlPatterns属性用于指定映射地址；asyncSupported属性用于指定是否支持异步操作模式；loadOnStartup属性用于指定Servlet的加载顺序；name属性用于指定Servlet的name属性；displayName属性用于指定该Servlet的显示名；initParams属性用于指定一组Servlet初始化参数。]]></content>
      <categories>
        <category>Java</category>
        <category>Java EE</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java EE</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet（一）之Servlet技术简介]]></title>
    <url>%2F2018%2F09%2F27%2FServlet%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BServlet%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[引言：Servlet是在JSP之前就存在的运行在服务端的一种Java技术，它是用Java语言编写的服务器端程序。在JSP技术出现之前，Servlet被广泛地应用来开发动态的Web应用程序。 1. Servlet技术简介Servlet是一种独立于平台和协议的服务器端的Java技术，可以用来生成动态地Web页面。Servlet是使用Java Servlet应用程序设计接口（API）及相关类和方法的Java程序。Java语言能够实现的功能，Servlet基本上都能实现（除了图形界面外）。Servlet主要是用于处理客户端传来的HTTP请求，并返回一个响应。通常所说的Servlet就是指HttpServlet，用于处理HTTP请求，其能够处理的请求有doGet()、doPost()、service()等方法。在开发Servlet时，可以直接继承javax.servlet.http.HttpServlet。 在Servlet3.0以前的版本中，只能在web.xml文件中配置Servlet，而在Servlet 3.0中除了在web.xml文件中配置以外，还提供了利用注解来配置Servlet。 2. Servlet技术功能Servlet通过创建一个框架来扩展服务器的能力，以提供在Web上进行请求和响应的服务。当客户机发送请求至服务器时，服务器可以将请求信息发送给Servlet，并让Servlet建立起服务器返回给客户机的响应。当启动Web服务器或客户机第一次请求服务器时，可以自动装入Servlet，之后，Servlet继续运行直到其他客户机发出请求。Servlet的功能涉及范围很广，主要功能如下： 创建并返回一个包含基于客户请求性质的动态内容完整的HTML页面； 创建可嵌入到现有HTML页面中的一部分HTML页面； 与其它服务器资源进行通信； 用多个客户机处理连接，接收多个客户机的输入，并将结果传递到多个客户机上。例如：Servlet可以是多名参与者的游戏服务器； 将订制的处理提供给所有服务器的标准程序。 3. Servlet技术特点Servlet技术带给程序员最大的优势是它可以处理客户端传来的HTTP请求，并返回一个响应。总的来说，Servlet技术具有以下特点。 高效。在服务器上仅有一个Java虚拟机在运行，它的优势在于当多个来自客户端的请求进行访问时，Servlet为每个请求分配一个线程而不是进程。 方便。Servlet提供了大量的实用工具例程，例如处理很难完成的HTML表单数据、读取和设置HTTP头、处理Cookie和跟踪会话等。 跨平台。 功能强大。 灵活性和可扩展性。 共享数据。Servlet之间通过共享数据可以很容易地实现数据库连接池。 安全。 4.Servlet地生命周期在Servlet地整个生命周期中，Servlet地处理过程如下图所示。 图中所示各步骤的说明如下。 第一步：用户通过客户端浏览器请求服务器，服务器加载Servlet，并创建一个Servlet实例； 第二步：容器调用Servlet的init()方法； 第三步：容器调用service()方法，并将HttpServletRequest和HttpServletResponse对象传递给该方法，在service()方法中处理用户请求； 第四步：在Servlet中请求处理结束后，将结果返回给容器； 第五步：容器将结果返回给客户端进行显示； 第六步：当Web容器关闭时，调用destroy()方法销毁Servlet实例。 注：初始化init()和销毁destroy()方法只执行一次。 下面一段代码采用web.xml配置的Servlet实现（这里我用的时IDEA，请自行导入Servlet依赖）： MyServlet.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.heng.servlet;import javax.servlet.*;import java.io.IOException;import java.io.PrintWriter;public class MyServelt implements Servlet &#123; /** * 初始化调用init()方法（只调用一次） * @param servletConfig * @throws ServletException */ @Override public void init(ServletConfig servletConfig) throws ServletException &#123; System.out.println(&quot;init()方法被调用。。。&quot;); &#125; /** * 处理客户端请求并做出响应 * @param servletRequest * @param servletResponse * @throws ServletException * @throws IOException */ @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println(&quot;service()方法被调用。。。&quot;); servletResponse.setContentType(&quot;text/html;charset=gb2312&quot;); PrintWriter out = servletResponse.getWriter(); out.println(&quot;&lt;h1 style=&apos;color:red&apos;&gt;hello Servlet&lt;/h1&gt;&quot;); out.println(&quot;&lt;h2 style=&apos;color:red&apos;&gt;Servlet生命周期实例&lt;/h2&gt;&quot;); &#125; /** * 当Web容器关闭时调用destroy()方法，（只调用一次） */ @Override public void destroy() &#123; System.out.println(&quot;destroy()方法被调用。。。&quot;); &#125; /** * 获取Servlet相关配置属性（用的较少） * @return */ @Override public ServletConfig getServletConfig() &#123; return null; &#125; /** * 获取Servlet相关信息（用的较少） * @return */ @Override public String getServletInfo() &#123; return null; &#125;&#125; web.xml 12345678910111213141516&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.heng.servlet.MyServelt&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 运行结果： 采用注解方式开发是比较简单的，不需要在web.xml中写一大堆配置代码，这里用一句话就可以代替上面的web.xml配置文件，只需要在MyServlet.java的类上加一个注解即可。 1234@WebServlet(&quot;/helloServlet&quot;)public class MyServelt implements Servlet &#123; //其它代码和上面一致，只是不需要配置web.xml&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java EE</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java EE</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程（二）线程的创建]]></title>
    <url>%2F2018%2F09%2F26%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[引言：前面讲到了进程和线程的概念，接下来就记录下线程是如何创建并启动的。 1.Java中的线程有两方面的含义：一是一条独立的执行线索，二是java.lang.Thread类或是其子类的对象。在Java中开发自己的线程有两种方式，包括继承Thread类与实现Runnable接口。 1）继承Thread类 若一个类直接或间接继承自Thread类，则该类对象便具有了线程的能力。这是最简单的开发线程的方式，采用此方法最重要的是重写继承的run()方法。基本语法如下： 12345class &lt;类名&gt; extends Thread&#123; public void run()&#123; //doString &#125;&#125; 上述格式中，run()方法中编写的是线程所要执行的任务代码，一旦线程启动，run()方法中的代码将成为一条独立的执行线索。run()方法是可以重载的，但重载的该方法，不再具有成为一条执行线索的能力，在开发中注意不能写错。 2）实现Runnable接口 由于Java中采用的是单一继承，一个类只能唯一的继承与另一个类。如果只能通过继承Thread类来定义自己的线程，在实际的开发中有很多限制。因此，Java中提供了一个名为Runnable（java.lang.Runnable）的接口，此接口中有一个具有如下申明的抽象方法： 1public abstract void run(); 这样，实现了Runnable接口的类中同样也就具有了描述线程任务的run()方法，此run()方法也可以在一定的条件下成为一条独立的执行线索。 无论使用哪种方式，都可以通过一定的操作得到一条独立的执行线索，然而二者之间不是完全相同的，下面对二者之间的异同进行了比较。继承Thread类的方法虽然最简单，但继承了该类就不能够再继承别的类，这在有些情况下会严重影响开发。其实，很多情况下只是希望自己的类具有线程的能力，扮演线程的角色，而自己的类还需要继承其他类。实现Runnable接口既不影响继承其他类，也不影响实现其他接口，只是实现Runnable接口的类多扮演了一种角色，多了一种能力而已，灵活性更好。 2.线程的创建 对于继承Thread类与实现Runnable接口两种不同方式，在创建线程对象这一步是有区别的。 1）继承Thread类方式 继承Thread的类，在创建线程对象时非常简单。其继承了Thread类，因此其自身的对象便是线程对象，在创建线程对象时只需要创建自身的对象即可。 12//继承Thread的类创建线程对象,其中MyThread类继承与Thread类Thread thread = new MyThread(); 继承Thread的类创建线程对象的方式与别的类创建对象的方式完全一样。 2）实现Runnable接口方式 对于实现Runnable接口的类，其自身的对象并不是一个线程，只是在该类中通过实现run()方法指出了线程需要完成的任务。然而，若想得到一个线程，必须创建Thread类或其子类的对象，这时就需要使用Thread类的特定构造器来完成这个工作，下表为Thread类的常用构造器： 构造器声明 功能 public Thread() 该构造器将构造一个新的线程对象，该对象启动后将运行自身的run()方法，并且该对象具有默认的名称。 public Thread(Runnable target) 参数target为指定的Runnable实现类，该构造器将构造一个新的线程对象，当该对象启动后将执行指定的target中的run()方法，该对象具有默认的名称。 public Thread(Runnable target,String name) 参数target为指定的Runnable实现类，参数name为指定的名称，该构造器将构造一个新的线程对象，当该对象启动后将执行指定target中的run()方法，该对象具有指定的名称。 public Thread(String name) 参数name为指定的名称，该构造器将构造一个新的线程对象，该对象启动后将运行自身的run()方法，并且该对象具有指定的名称。 从Thread类的构造器列表中可以看出，当创建线程对象时，只需要首先创建实现Runnable接口的类的对象，然后将此对象的引用传递给Thread类构造器即可，这中方式实际上是在告诉我们线程对象要执行的任务（run()方法）在哪里。 下面的例子说明了这个问题，代码如下： 1234//创建实现Runnable接口的类的对象Runnable myRunnable = new MyRunnable();//创建Thread对象，将第一步创建的对象的引用作为构造器参数Thread thread = new Thread(myRunnable); 当然，实现Runnable接口的类的对象可以被同时传递给多个线程对象，如下面的代码： 123456//创建实现Runnable接口的类的对象Runnable myRunnable = new MyRunnable();//创建几个Thread对象，将第一步创建的对象的引用作为构造器参数Thread thread1 = new Thread(myRunnable);Thread thread2 = new Thread(myRunnable);Thread thread3 = new Thread(myRunnable); 上述代码也就意味着这几个线程对象启动后将执行完全相同的任务。另外，Thread类本身也实现了Runnable接口，因此Thread类及其子类的对象也可以作为target参数传递给新的线程对象。 当线程对象创建完成后，其还是一个普通的对象，并没有成为一条对立的执行线索。想让其成为独立的执行线索必须启动，在没有启动的情况下，开发人员可以像调用其他对象的方法一样调用线程对象中的任何可见方法。run()方法也可以作为普通方法一样调用，但调用了run()方法并不代表新建了执行线索，run()方法还是在调用它的线程中执行。 下面一段代码简单的描述线程的创建和启动： 12345678910111213141516171819202122232425262728293031323334package com.heng.thread;public class test1 &#123; static class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;我是一个继承Thread的线程&quot;); &#125; &#125; static class MyRunnable implements Runnable&#123; public void run() &#123; System.out.println(&quot;我是一个实现Runable接口的线程&quot;); &#125; &#125; public static void main(String args[])&#123; /** * 创建MyThread实例对象，并用start()方法启动线程。 */ Thread thread1 = new MyThread(); thread1.start(); /** * 创建MyRunnable实例对象，将引入参数传递给Thread的构造器中，并用start()方法启动线程。 */ Runnable myRunnable = new MyRunnable(); Thread thread2 = new Thread(myRunnable); thread2.start(); System.out.println(&quot;main 方法&quot;); &#125;&#125; 运行结果： 今天的线程内容就先讲到这里，下节内容我们继续围绕线程，讲解线程的常用方法、线程的同步、线程的安全、悲观锁/乐观锁以及我们为什么使用多线程开发。]]></content>
      <categories>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java SE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程（一）概念]]></title>
    <url>%2F2018%2F09%2F22%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[引言：随着多核CPU的问世，使得多线程程序在开发中占有了更重要的位置。但是什么是进程？什么是线程？它们之间到底又有什么关系呢？下面就来详细的来介绍一下它们的概念。 1.什么是进程？简单一句话，进程是正在运行的程序的实例。进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程是基本的分配单元，也是基本的执行单元。 进程的概念主要有两点： 进程是一个实体，每一个进程都有它自己的地址空间。一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。 进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。 特征 动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的； 并发性：任何进程都可以同其他进程一起并发执行； 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位； 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进； 结构特征：进程由程序、数据和进程控制块三部分组成。 状态进程执行时的间断性，决定了进程可能具有多种状态。事实上，运行中的进程可能具有以下三种基本状态。 1）就绪状态（Ready）：进程已获得除处理器外的所需资源，等待分配处理器资源；只要分配了处理器进程就可执行。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。 2）运行状态(Running)：进程占用处理器资源；处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以执行时(如所有进程都在阻塞状态)，通常会自动执行系统的空闲进程。 3）阻塞状态(Blocked)：由于进程等待某种条件（如I/O操作或进程同步），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行。 2.什么是线程？线程的引入： 60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（SMP）出现，可以满足多个运行单位，而多个进程并行开销过大。因此在80年代，出现了能独立运行的基本单位——线程（Threads）。 一个进程包含一个或多个线程。线程是程序运行最小的调度单位。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。 多线程编程可以是程序具有多条并发执行线索，就像日常工作中由多人同时合作完成一个任务。这在很多情况下可以改善程序的响应性能，提高资源的利用效率，在多核CPU年代，这显得尤为重要。然而滥用多线程也有可能给程序带来意想不到的错误，减低程序执行的效率。 使用多线程开发优点： 在多核CPU系统中，使用线程可以提高程序响应速度，提高CPU和内存的利用率； 多线程开发可以将耗时操作放入子线程，提高效率； 资源利用率更好； 程序设计在某些情况下更简单，改善程序结构，降低耦合性； 程序响应更快； 可以随时停止任务； 等等… 使用多线程开发缺点： 等候共享资源时造成程序的运行速度变缓慢。这些共享资源主要是独占性的资源，如打印机等； 对线程进行管理要求额外的CPU开销。线程的使用会给系统带来上下文切换的额外负担； 在某些情况下可能会造成线程的死锁。即较长时间的等待或者资源竞争以及死锁等； 对共享变量同时进行读写的不可预测性错误等等。 总之有优点肯定就会有缺点，毕竟谁也不能做到十全十美。后面会讲到Java开发中是如何避免这些缺点的。 线程的五种状态 1)新建状态使用new运算符创建一个线程后，该线程仅仅是一个空对象，系统没有分配资源，称该线程处于创建状态（new thread）。 2)可运行状态使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，是该线程处于可运行状态（Runnable）。 3）运行中状态Java运行系统通过调度选中一个Runnable的线程，使其占有CPU并转为运行中状态（Running）。此时，系统真正执行线程的run()方法。 4）阻塞状态一个正在运行的线程因某种原因不能继续运行时，进入阻塞状态（Blocked）。 5）死亡状态线程结束后是死亡状态（Dead）。 OK，基础概念知识就先写到这里，后面会讲解到如何建立一个线程，以及多线程编程。]]></content>
      <categories>
        <category>Java</category>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java SE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统重装后如何恢复Hexo博客]]></title>
    <url>%2F2018%2F09%2F20%2F%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E5%90%8E%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8DHexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[说明由于暑假电脑出了故障，重装了系统。导致本地电脑搭建的Github+Hexo博客不能正常使用，也由于时间原因到现在才有时间来恢复博客（不会断的）。现在简单记录下是如何恢复已有的Hexo博客。 恢复步骤 重点： 重装系统前的博客有备份（整个文件，也就是与最后一次上传到GitHub保持一致，包括配置文件。PS：养成备份的好习惯。）。 第一步：恢复本地按照搭建博客步骤重新安装Git,Node.js,Hexo。可参考《GitHub + Hexo 搭建》，执行到4-1操作步骤后，进入原有hexo文件目录内输入如下命名： hexo s 如果服务器启动成功，并在浏览器中输入http://localhost:4000可以看到博客，则表明本地恢复成功。如果不成功，检查Git,Node.js,Hexo安装是否正确，重来一遍。 第二步：恢复同步GitHub功能第一步正确执行后，接下来我们就要开始恢复博客上传到远程Github上的功能了。可参考《GitHub + Hexo 搭建》，从4.5步骤开始，从新配置用户名和邮箱。 在Blog文件夹目录内右击打开Git Bash Here窗口，输入以下命令： git config --global user.name "GitHub用户名" git config --global user.email "GitHub邮箱" 重点：重新生成SSH KEY（系统重装后是没有的，需要重新生成），GitHub需要一个密钥才能与本地相连接，执行以下命名，并且连续按3次回车生成密钥（注：C 为大写）： ssh-keygen -t rsa -C "邮箱地址" 后面会有一个地址，可以看到。就是我们生成的密钥保存地址。即：C:/Users/用户名/.ssh文件中。打开这个目录找到 id_rsa.pub 文件，复制全部内容。 在网页打开GitHub，依次点击 我的头像 - Settings - SSH and GPG keys - New SSH key，将刚刚复制的密钥内容粘贴到key的输入框（可以将原来的密钥删除），然后点击Add Key，配置成功。 最后，测试一下，按照以前的方式随便写一篇文章上传一下，如何成功了，那么我们就大功告成了！！！]]></content>
      <categories>
        <category>Hexo</category>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 常用快捷键]]></title>
    <url>%2F2018%2F06%2F23%2FIDEA-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[IDEA 现在是越来越火的一款开发工具，很多公司都在使用它来开发软件。具体简介就不讲了，下面说一些IDEA 开发工具常用的一些快捷键，能帮助我们高效地开发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101Ctrl + Alt + S 打开设置选项Ctrl + / 注释 、 取消注释（单行注释）Ctrl + Shift + / 注释 、取消注释（多行注释）Ctrl + N 查找类文件Ctrl + Shift + N 查找文件Ctrl + Y 删除当前行Ctrl + D 复制当前行到下一行Ctrl + X 剪切当前行（也有删除当前行的作用）Ctrl + V 粘贴Ctrl + R 替换Ctrl + F 在当前文件中查找 （使用 F3 在查找到的多个结果中切换）Ctrl + Shift + F 在指定范围查找（更详细）Ctrl + P 查看一个函数可以使用的参数 / 查看一个属性有哪些可用的值 等等Ctrl + Shift + 1, 2, 3, 4 在某一行打标签。结合 Ctrl + 1, 2, 3, 4 可以快速定位到某一标记行。 适用于行数特别多的文件。Ctrl + delete 删除一个连续的单位。比如，单词、连在一起的单词、连在一起的汉字等。Ctrl + W 选择一个单位。连续按的话，会不断扩展选择的范围。Ctrl + 左右箭头（导航键左右键） 按照单位跳转。Ctrl + (-/+) 收起或者展开一段代码块（比如，一块注释或者一个方法太长，可以按Ctrl + - 将它收起来）Ctrl + E 打开最近的文件Ctrl + Shift + E 打开最近编辑过的文件Ctrl +Tab 直接打开最近的文件Ctrl + F12 查看当前文件的内部成员 或者说 查看本文档的结构Ctrl + G 跳转到指定行Ctrl + F4 关闭当前文件Ctrl + B 打开一个类（java）的声明，其他如html jsp文件也是类似。相当于在eclipse中编辑java类文件时，按住Ctrl键并单击类名从而进入类的声明。Ctrl + H 查看当前类的继承关系（按Shift + Esc 关闭）Ctrl + Shift 查看一个方法的继承关系（按Shift + Esc 关闭）Ctrl + Q 查看说明文档Ctrl + Alt + L 格式化代码Ctrl + Shift + I 查看类体或者方法体Ctrl + Alt + O 自动导包 Ctrl + Alt + Enter 在当前行上面开启新的一行Ctrl + Shift + 上下箭头 上下移动代码块（对比Alt + Shift + 上下箭头） Ctrl + Shift + U 切换大小写Ctrl + Shift + V 选择性粘贴（剪切板有多个选项）Ctrl + Shift + C 复制当前文件的路径Ctrl + Shift + J 合并下一行到当前行Ctrl + Shift + (-/+) 折叠或者展开所有代码块Ctrl + Shift + Space 自动提示Alt + Enter 根据提示自动导入包Alt + 左右箭头 在当前打卡的多个文件之间跳转Alt + / 自动补全Alt + 鼠标选区 可以选择方形区域（列模式）Alt + Home 锁定到导航栏目，按导航键可以直接打开文件Alt + Insert 插入构造方法、toString方法等Alt + F7 查看方法在哪里被调用了Shift + F6 重命名 （比如，选中名为 thread 的变量，按Shift + F6 进行重命名，可以对本类中所有原来名为thread的变量进行重命名）Shift + Enter 在当前行下面开启新的一行Shift + Home / End 选择光标到行首/行尾的区域Shift + 导航箭头 自由选择Shift + F11 查看书签]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）Spring系列之SpringMVC入门]]></title>
    <url>%2F2018%2F06%2F21%2F%EF%BC%88%E4%B8%80%EF%BC%89SpringMVC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[说明：本章主要介绍了springMVC的基础知识和一个简单的登陆过程实例 1. 初识SpringMVC什么是MVC MVC是一种Web程序设计模式、软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写 先给一张官网图： 再看下这张图： 2. 什么是SpringMVC SpringMVC 是一个基于mvc的一种web应用框架，是Spring的一个模块。 与Spring无缝连接，不需要配置。 再看这张图： 化重点： 前端控制器（DispatchServlet） 接收客户端请求，返回响应结果，相当于中央处理转发器。 映射器（HandleMapping） 根据请求的URL查找Handle。 适配器（HandleAdapter） 按照特定规则（HandleAdapter要求的规则）执行Handle。 处理器（Handle ）（需要我们编写Controller） 处理业务逻辑，返回ModelAndView。 视图解析器（ViewResolve） 解析处理器返回的视图，然后返回View 3. 一个登陆的实例先给个项目结构截图： 3.1 新建一个项目注： 这里我们使用的是IDEA 2018 开发工具（Eclipse也可以，环境搭好就行） 新建一个Maven -&gt; webapp 项目，然后在src/main下面新建 java和resources目录，并标记为根目录,配置Tomcat等等。 具体可参考： 在IDEA上搭建Spring项目 3.2 导入jar包在pom.xml文件下导入依赖包,代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!--版本控制--&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;slf4j-version&gt;1.7.25&lt;/slf4j-version&gt; &lt;spring.version&gt;5.0.4.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- spring相关包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志相关包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.3 在web.xml中配置前端控制器（DispatchServlet）123456789101112131415161718192021222324252627&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3.0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--下面的contextConfigLocation配置springMVC加载的配置文件，映射器、处理器、视图解析器的文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--访问DispatchServlet对应的路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.4 在resources目录下新建一个 springmvc-servlet.xml 配置文件注： 要与web.xml 文件中加载的配置文件名一致 springmvc-servlet.xml 代码如下： 1234567891011121314151617181920212223&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描controller--&gt; &lt;!--扫描&quot;com.heng.controller&quot;包下所有的类--&gt; &lt;context:component-scan base-package=&quot;com.heng.controller&quot;/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- jsp所在的位置（前缀）--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt; &lt;!-- jsp文件的后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 附 log4j.properties 配置代码（同样在resources目录下）： 1234567891011121314###setloglevels###INFOlog4j.rootLogger=INFO,stdout,Elog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125;%5p %c&#123;1&#125;:%L-%m%nlog4j.logger.org.quartz=INFOlog4j.appender.E=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File=logs/mylogs.loglog4j.appender.E.DatePattern=yyyy-MM-dd&apos;.log&apos;log4j.appender.E.Threshold=INFOlog4j.appender.E.layout=org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern=%-d&#123;yyyy-MM-ddHH\:mm\:ss&#125;[%c][%t\:%r]-[%p]%m%n 3.5 Controller编写 在java目录下新建包 com.heng.controller 新建一个UserController类 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Controller@SessionAttributes(&quot;user&quot;) //表示：user 这个值需要写到httpsession中public class UserController &#123; /** * 访问根路径请求的映射 * */ @RequestMapping(&quot;/&quot;) public String main(Map&lt;String ,Object&gt; map)&#123; //如果session中没有保存用户的信息，则需要跳转到login页面 if(map.get(&quot;user&quot;) == null)&#123; return &quot;redirect:/login&quot;; &#125; return &quot;main&quot;; &#125; /** * 加载登录页面执行的映射 * */ @RequestMapping(value = &quot;/login&quot;,method = RequestMethod.GET) public String login()&#123; return &quot;login&quot;; &#125; /** * 登录请求URL执行的映射 * */ @RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST) public String login(String userName, String password, Map&lt;String,Object&gt; map)&#123; if(&quot;admin&quot;.equals(userName) &amp;&amp; &quot;123&quot;.equals(password))&#123; map.put(&quot;user&quot;,userName); return &quot;redirect:/&quot;; &#125; map.put(&quot;msg&quot;,&quot;验证失败，请重新登录！&quot;); return &quot;login&quot;; &#125; /** * 退出请求URL执行的映射 * */ @RequestMapping(&quot;/logout&quot;) public String logout(Map&lt;String,Object&gt; map, SessionStatus status)&#123; //从session中删除用户信息 map.remove(&quot;user&quot;); //更新session status.setComplete(); //重定向到login页面 return &quot;redirect:/login&quot;; &#125;&#125; 6. 附 jsplogin.jsp 代码如下： 123456789101112131415161718192021222324252627282930&lt;%-- Created by IntelliJ IDEA. User: Heng Date: 2018/6/21 Time: 14:18 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% String basePath = request.getContextPath(); String msg = (String)request.getAttribute(&quot;msg&quot;);%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&lt;%=basePath%&gt;/login&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;userName&quot;&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot; id=&quot;userName&quot;/&gt;&lt;/label&gt;&lt;br/&gt; &lt;label for=&quot;password&quot;&gt;密&amp;nbsp;&amp;nbsp;码：&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot;/&gt;&lt;/label&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;/form&gt; &lt;h3&gt;&lt;%=msg == null ? &quot;&quot; : msg%&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; main.jsp 代码如下： 12345678910111213141516171819202122&lt;%-- Created by IntelliJ IDEA. User: Heng Date: 2018/6/21 Time: 14:27 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% String basePath = request.getContextPath();%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt; Hello Spring!&lt;/h2&gt; &lt;form action=&quot;&lt;%=basePath%&gt;/logout&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;退出登录&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; OK，到此简单的一个SpringMVC入门小程序就完成了]]></content>
      <categories>
        <category>Java</category>
        <category>Java EE</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java EE</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在IDEA上搭建Spring+SpringMVC+Hibernate项目]]></title>
    <url>%2F2018%2F06%2F19%2F%E5%9C%A8IDEA%E4%B8%8A%E6%90%AD%E5%BB%BASpring%2BSpringMVC%2BHibernate%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[说明：本章主要介绍如何在idea上搭建一个简单的基于Maven的Spring+SpringMVC+hibernate项目。并没有细分各个业务逻辑层次划分。 参考博文 大家如果想深入剖析项目搭建步骤可参考上面博客。 重点：准备工作 安装好jdk1.8以上版本、配好环境变量 安装好Tomcat（我是Tomcat9） 安装好maven （也可选择IDEA自带的） 安装好IDEA（上篇博客已经介绍了完整版的idea安装和破解，大家可以参考。） 一.创建一个新项目1. 点击左上角 File -&gt; new project -&gt; maven -&gt;webapp。 2. 填项目名称 3. 选择maven版本 4. 进入页面后在右下角会弹出一个对话框，选择导入依赖包（没有则不管） 5. 这是默认建好的目录 二. 项目建好过后，我们就要进行配置了1.使用pom.xml导入依赖包，先考虑你要做什么项目，需要什么包，这个自己好好想一下，其实基本的包都类似，主要的是版本不同因为我们是用Maven搭建项目的，只需要在根目录下的pom.xml文件中加入需要的依赖包版本信息，就可以自动下载导入所有我们需要的包（这个还是很贴心的）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240&lt;!--版本号--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;4.3.1.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;!-- 依赖从这开始 --&gt; &lt;dependencies&gt; &lt;!--日志包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;!--j2ee相关包 servlet、jsp、jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加Hibernate依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;3.6.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javassist/javassist --&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.12.1.GA&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring相关包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--其他需要的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!--jackson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;ssm&lt;/finalName&gt; &lt;resources&gt; &lt;!--表示把java目录下的有关xml文件,properties文件编译/打包的时候放在resource目录下--&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 2. maven是自动导包，导完过后我们就可以看到我们需要的依赖包已经全部导入了 三. SpringMVC配置1. 先建好需要我们手动建立的必须文件夹，在界面右上角点击 Project Structure -&gt; Modules 建立所缺少的java、resources文件夹，并标记属性。 建好后的目录： 2. 配置web.xml如果生成的web.xml版本不是3.0的，需要手动改为3.0同时需要在resources下创建spring/spring-mvc.xml文件，因为在web.xml配置中我们需要引用，先建立文件夹，后面再配置 web.xml 代码如下： 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;!--welcome pages--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--配置springmvc DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--resources标注的文件夹下需要新建一个spring文件夹--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3. 配置spring-mvc.xml现在我们创建的java目录下创建的基础包com.test.controller包，在spring-mvc.xml中需要指明这个包，然后在这个包下创建的Controller类使用的@Controller注解才会生效。 spring-mvc.xml 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--启用spring的一些annotation --&gt; &lt;context:annotation-config/&gt; &lt;!-- 自动扫描com.test.controller包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;com.test.controller&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!-- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt; &lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt; &lt;bean id=&quot;defaultViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;&lt;!--设置JSP文件的目录位置--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- springmvc文件上传需要配置的节点--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;20971500&quot;/&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;resolveLazily&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- 使用jackjson,默认将返回对象转换为 JSON，如果前面没有在pom文件中添加jackson包的不需要这个配置 --&gt; &lt;bean id=&quot;stringConverter&quot; class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jsonConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;&lt;/bean&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;stringConverter&quot; /&gt; &lt;ref bean=&quot;jsonConverter&quot; /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4. 基本配置弄好了，接下来我们就来配置服务器 然后点OK 5. 接口现在com.test.controller下创建UserController类 然后创建com.test.entity包，在包下创建一个UserEntity类 UserController.java 1234567891011121314@Controller@RequestMapping(&quot;/sshTest&quot;)//Contoller下所有接口统一入口public class UserController &#123; //映射一个action @RequestMapping(&quot;/getuser&quot;) @ResponseBody//表示直接输出返回内容，不进行jsp或html跳转，本例是为了写接口，这里直接返回json public UserEntity getUser() &#123; //创建一个UserEntity，直接返回 UserEntity user = new UserEntity(&quot;heng&quot;, &quot;123456&quot;); return user; &#125;&#125; UserEntity.java 12345678910111213141516171819202122232425262728293031public class UserEntity &#123; private String username; private String password; public UserEntity(String username, String password) &#123; this.username = username; this.password = password; &#125; public UserEntity() &#123; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125;&#125; 注：这里大家可以自己百度下如何设置自动导包和手动导包，以及类属性的get和set方法，以及构造方法怎么生成的。 6. 启动Tomcat服务器，然后打开浏览器，输入 http://localhost:8080/sshTest/getuser 查看是否成功。 springMVC集成完毕，接下来就是hibernate的配置了 四. Hibernate配置先把我们需要用的窗口调出来 view-&gt; 1. 配置hibernate.cfg.xml首先我们要创建hibernate.cfg.xml文件，idea提供了直接自动生成hibernate配置文件的功能。点击右上角的 Project Structure -&gt; Modules -&gt; + -&gt; Hibernate 然后点OK，结果如下图： hibernate.cfg.xml 代码如下： 12345678910111213141516171819202122232425&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--配置连接数据库的基本信息--&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;0117love&lt;/property&gt; &lt;!--mysql驱动--&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;!-- 配置 Hibernate 的基本信息 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 指定自动生成数据表的策略 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 2. hibernate配置文件生成了，接下来我们就使用hibernate的自动映射出数据库实体类的功能，这里idea都提供了可视化操作，非常简单，我们要先为idea也配置一个数据库连接，点击Database。 结果如下： 到这里idea的MySQL连接也配置好了，接下来就可以直接使用可视化工具创建hibernate实体类，点击Persistence，右键配置好的hibernate–&gt;Generate Persitence Mapping–&gt;by Database schema 接下来这张表是我自己已经创建的表： 注：想要参考如何建表，请参考最后附录 接下来就可以看到我们自动生成的持久化注解类： 到这里我们的hibernate的集成也已经完成，接下来做一次对studentInfo表的查询操作，并将查询到的数据以json的形式返回在浏览器上。 1.新建com.test.dao包2.创建一个StudentDao的逻辑类，用于对studentInfo表的增删改查 StudnetDao.java 1234567891011121314151617181920212223242526272829303132333435public class StudentDao &#123; /** * 查询表中所有数据 * */ public List&lt;StudentinfoEntity&gt; query() &#123; Session session = null; List&lt;StudentinfoEntity&gt; list = null; try &#123; //实例化Configuration，这行代码默认加载hibernate.cfg.xml文件 Configuration conf = new Configuration().configure(); //以Configuration创建SessionFactory SessionFactory sf = conf.buildSessionFactory(); //实例化Session session = sf.openSession(); String hql = &quot;from StudentinfoEntity&quot;; Query query = session.createQuery(hql); list = query.list(); &#125; catch (HibernateException e) &#123; e.printStackTrace(); return null; &#125; finally &#123; if (session != null) &#123; session.close(); &#125; &#125; return list; &#125;&#125; 接下来就在包controller下创建一个StudentController.java类，调用StudentDao接口实现查询学生信息： StudentController.java 123456789101112131415@Controller@RequestMapping(&quot;/student&quot;)//Contoller下所有接口统一入口public class StudentController &#123; //映射一个action @RequestMapping(&quot;/studentList&quot;) @ResponseBody public List&lt;StudentinfoEntity&gt; getUser() &#123; StudentDao dao = new StudentDao(); //查询studentInfo的所有数据，返回json格式 return dao.query(); &#125;&#125; 五. OK，最后一步重启Tomcat服务器，在浏览器地址栏，输入 http://localhost:8080/student/studentList 附录：注：我写的数据库名为test，自己改 studenetInfo表创建： 123456789101112131415SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for studentinfo-- ----------------------------DROP TABLE IF EXISTS `studentinfo`;CREATE TABLE `studentinfo` ( `id` int(11) NOT NULL, `name` varchar(255) NOT NULL, `passwrod` varchar(255) NOT NULL, `age` int(11) NOT NULL, `address` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 数据插入： 12345INSERT INTO `studentinfo` VALUES (1, &apos;恒&apos;, &apos;123&apos;, 20, &apos;成都&apos;);INSERT INTO `studentinfo` VALUES (2, &apos;aaaa&apos;, &apos;123&apos;, 20, &apos;北京&apos;);INSERT INTO `studentinfo` VALUES (3, &apos;bbbb&apos;, &apos;123&apos;, 20, &apos;上海&apos;);INSERT INTO `studentinfo` VALUES (4, &apos;cccc&apos;, &apos;123456&apos;, 20, &apos;深圳&apos;);]]></content>
      <categories>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA开发工具安装与破解]]></title>
    <url>%2F2018%2F06%2F19%2FIDEA%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[说明：本章专门介绍Idea开发工具的安装与破解（当然你要是有钱任性，也可以不用破解） 安装步骤1. 进入IDEA官网下载安装包 官网链接 1.1在首页点击download下载安装包，注意我们这里是下载完整版（Ultimate），因为社区办不支持Java EE、Spring开发。 1.2安装过程都是傻瓜式安装，没有其它需求一直next就行。（注意：其中有个环节选择64位版就行，其它可以不用选（.java .kt 等等）） 2.安装完成后配置2.1 主题有默认黑色，还有其它可自定义2.2 激活 首先，编辑C:\Windows\System32\drivers\etc下的hosts文件，在文件最后加入下面一行： 0.0.0.0 account.jetbrains.com 如果你没有权限修改，先将hosts文件剪切到桌面，在桌面上打开文件，在进行添加上面代码。然后在剪切回去。 在激活界面选择Activation code方式激活，并填入下列激活码： EB101IWSWD-eyJsaWNlbnNlSWQiOiJFQjEwMUlXU1dEIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In1dLCJoYXNoIjoiNjk0NDAzMi8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-Gbb7jeR8JWOVxdUFaXfJzVU/O7c7xHQyaidCnhYLp7v32zdeXiHUU7vlrrm5y9ZX0lmQk3plCCsW+phrC9gGAPd6WDKhkal10qVNg0larCR2tQ3u8jfv1t2JAvWrMOJfFG9kKsJuw1P4TozZ/E7Qvj1cupf/rldhoOmaXMyABxNN1af1RV3bVhe4FFZe0p7xlIJF/ctZkFK62HYmh8V3AyhUNTzrvK2k+t/tlDJz2LnW7nYttBLHld8LabPlEEjpTHswhzlthzhVqALIgvF0uNbIJ5Uwpb7NqR4U/2ob0Z+FIcRpFUIAHEAw+RLGwkCge5DyZKfx+RoRJ/In4q/UpA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 注：如果该激活码有问题可到 http://idea.lanyus.com/ ，获取激活码 最后：完成安装、可以建一个简单的java项目测试一下安装是否成功…]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub + Hexo 搭建]]></title>
    <url>%2F2018%2F06%2F15%2FGitHub%2BHexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[说明这里还是简单的记录一下基于GitHub+Hexo+Next的个人博客搭建把，防止以后忘了… 搭建步骤 1. Git下载与安装Git是目前非常受欢迎的一个开源的分布式版本控制系统，用于敏捷高效地处理任何或大或小的项目。具体的一些介绍和使用的不具体写了，自己看教程。 菜鸟教程链接 官网下载链接 2. GitHub 账号注册gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。作为一个程序猿，现在基本都有一个GitHub账号，来托管自己的代码，如果你没有那就Out了。 官方地址链接 3. Node.js 下载与安装Node.js也是目前特别火的一个后台服务端脚本语言。简单的说就是运行在服务端的JavaScript。基于Chrome JavaScript运行时建立的一个平台。运行速度快、性能非常好。 菜鸟教程链接 官网下载链接 4. 搭建个人博客Hexo 安装Hexo，在本地电脑随一个磁盘新建一个文件夹，比如取名Blog来存放自己的博客。在文件夹内右击点击Git Bash Here进入命令行窗口，执行以下代码： npm install -g hexo-cli 初始化Hexo，得到hexo文件夹，用于存放Hexo博客的所有文件。还是在刚刚那个窗口中执行以下代码： hexo init hexo 配置Hexo，安装hexo依赖文件,生成部署文件，分别执行以下代码： cd hexo npm install hexo generate 继续在命令行窗口输入以下代码，启动服务器(hexo server == hexo s)： hexo server 随便打开一个浏览器，地址栏输入 http://localhost:4000/ ，如果成功显示Hexo页面，则搭建成功。 将Hexo 博客部署到GitHub中 新建一个仓库，命名为：username.github.id 在本地命令行配置Git： 在Blog文件夹目录右击打开Git Bash窗口，输入以下命名 git config -- global user.name "GitHub 用户名" git config -- global user.email "GitHub 邮箱" 重点：生成 SSH KEY，其实就是生成一个公钥和密钥，GitHub需要一个密钥才能与本地相连接，执行以下命名，并且连续按3次回车生成密钥（注：C 为大写）： ssh-keygen -t rsa -C "邮箱地址" 后面会有一个地址，可以看到。就是我们生成的密钥保存地址。即：C:/Users/用户名/.ssh文件中。打开这个目录找到 id_rsa.pub 文件，复制全部内容。 在网页打开GitHub，依次点击 我的头像 - Settings - SSH and GPG keys - New SSH key，将刚刚复制的密钥内容粘贴到key的输入框，然后点击Add Key，配置成功。 修改hexo 文件下的_config.yml （站点配置文件）,修改 deploy 属性代码，将本地 hexo 项目托管到 GitHub 上，如下所示： deploy: type: git #部署的类型 repository: git@github.com:zqiheng/zqiheng.github.io.git # 仓库地址 branch: master #分支名称 message: hexo deploy #提交信息 然后执行下面的命令，安装hexo-deployer-git插件，快速把代码托管到GitHub上面 npm install hexo-deployer-git --save 最后执行下列命令，将hexo项目托管到GitHub平台上 hexo clean hexo generate hexo deploy 或： hexo clean hexo g hexo d 然后在浏览器输入：https://username.github.io/ 访问，可以看到自己部署的博客 最后说一下Hexo全局配置文件，具体代码如下： # Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site 站点信息配置 title: Heng Bolg #站点名 subtitle: 世上本没有路，走的人多了也就有了路... #站点副标题 description: 主要记录自己的学习记录与心得，在校学生一枚... #站点信息简介 keywords: author: 恒 #站点作者 language: zh-CN #站点语言，default 默认是英语， zh-CN 是中文 timezone: #时区，不填 avatar: /images/logo.png #图片 # URL 博客地址 ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: https://zqiheng.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory 目录设置 source_dir: source #源文件 public_dir: public #生成的网页文件 tag_dir: tags #标签 archive_dir: archives #归档 category_dir: categories #分类 code_dir: downloads/code # i18n_dir: :lang #国际化 skip_render: # Writing 文章布局 new_post_name: :title.md # File name of new posts default_layout: post #默认模板 titlecase: false # 标题转换成大写 external_link: true # 新标签页里打开连接 filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: #代码块设置 enable: true #语法高亮 line_number: true #显示行号 auto_detect: false tab_replace: # Home page setting 页设置 # path: Root path for your blogs index page. (default = '') # per_page: Posts displayed per page. (0 = disable pagination) # order_by: Posts order. (Order by date descending by default) index_generator: path: '' per_page: 4 #每页文章数量 order_by: page #-date # Category & Tag 分类和标签 default_category: uncategorized category_map: tag_map: # Date / Time format 日期/格式 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination 归档显示 ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions 扩展 ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next # Deployment 站点部署到GitHub上 ## Docs: https://hexo.io/docs/deployment.html deploy: type: git #部署的类型 repository: git@github.com:zqiheng/zqiheng.github.io.git # 仓库地址 branch: master #分支名称 message: hexo #提交信息 #查找 search: path: search.xml field: post format: html limit: 10000 5. Next下载与配置—更新时间：2018.06.17— 下载Next主题，在Hexo目录下右击进入Git Bash Here 窗口，输入下列命令 git clone https://github.com/iissnan/hexo-theme-next themes/next 启动主题 当克隆下载完成后，打开站点配置文件(hexo目录下的_config.yml)，找到 theme字段，并将其值更改为next # Extensions 扩展 ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next 重新启动服务器，在浏览器地址栏输入http://localhost:4000访问，检测配置是否成功。 主题文件配置，目录为（hexo\themes\next）下的_config.yml文件。 我使用的主题样式是： # Schemes #scheme: Muse #scheme: Mist scheme: Pisces #scheme: Gemini 配置左侧导航栏菜单按钮，在主题配置文件中，找到menu属性，做如下配置： menu: home: / || home #首页，后面的表示图标 categories: /categories/ || th #分类 archives: /archives/ || archive #归档 tags: /tags/ || tags #标签 about: /about/ || user #关于 #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 为标签categories、tags、about，创建相应的界面，代码如下： hexo new page 'categories' hexo new page 'tags' hexo new page 'about' 在 source目录下，会看到刚刚生成的三个文件夹，依次打开文件夹，给每个index.md文件添加上type字段。 配置左侧导航栏搜索按钮 安装 hexo-generator-searchdb ，在Git Bash Here窗口执行以下代码： npm install hexo-generator-searchdb --save 打开全局配置文件，在最后新增下面代码； search: path: search.xml field: post format: html limit: 10000 打开主题配置文件，找到local_search属性，开启本地搜索功能 local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 重新部署项目，并发布到GitHub上 hexo clean hexo g hexo d 基本配置就是这样，其它功能后面再补充]]></content>
      <categories>
        <category>Hexo</category>
        <category>个人博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F06%2F15%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[Hexo简介：简而言之，Hexo 是一个基于 Node.js 的静态博客程序，可以方便的生成静态网页托管在github和Heroku上。其作者是来自台湾的tommy351大神。Hexo 因其界面简洁、美观且对各类人群（不只是程序猿）友好而广受欢迎，声望不亚于大名鼎鼎的WordPress。 说明为什么需要一个博客对于个人网站来说,没有比博客更合适的形式了。在博客中,文章才是最主要的,一切都显得主次分明,干净利落。相比之下,论坛中主题和回复鱼龙混杂,阅读体验非常差。同时,博客比论坛的数据库小很多,便于维护。 为什么是静态博客很多人选择在虚拟主机或vps上面搭建动态博客。独立博客如此麻烦的维护工作,能不能减轻一些呢?正如阮一峰前辈所说,blogger分为三个阶段。最开始,是门户博客。之后,是独立博客。最后,觉得独立博客自己管理起来费劲,便找个别人来管的空间,自己负责写就好。如果我们能够找到这样的空间,在自己保留最大控制权前提下,由别人托管,会省去不少事情。 静态博客编译之后是纯html页面,优点就是支持它的环境十分好找,例如github、gitcafe等站点都支持静态页面托管,自然是我们的首选了。 但是静态博客并非没有缺点。动态博客更新文章时,脚本是不变的,只需要更新数据库。静态博客要频繁改动文件,不支持增量式上传的东西,比如ftp,就难于管理。此外,还要十分熟悉git各种命令,才能部署页面。]]></content>
      <categories>
        <category>Hexo</category>
        <category>简介</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
